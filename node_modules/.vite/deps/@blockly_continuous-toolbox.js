import {
  __publicField,
  __toESM,
  require_blockly_compressed
} from "./chunk-43MFHJTY.js";

// node_modules/blockly/blockly.mjs
var import_blockly_compressed = __toESM(require_blockly_compressed(), 1);
var {
  Block,
  BlockFlyoutInflater,
  BlockNavigationPolicy,
  BlockSvg,
  Blocks,
  ButtonFlyoutInflater,
  COLLAPSED_FIELD_NAME,
  COLLAPSED_INPUT_NAME,
  COLLAPSE_CHARS,
  CodeGenerator,
  CollapsibleToolboxCategory,
  ComponentManager,
  Connection,
  ConnectionChecker,
  ConnectionDB,
  ConnectionNavigationPolicy,
  ConnectionType,
  ContextMenu,
  ContextMenuItems,
  ContextMenuRegistry,
  Css,
  DELETE_VARIABLE_ID,
  DeleteArea,
  DragTarget,
  DropDownDiv,
  Events,
  Extensions,
  Field,
  FieldCheckbox,
  FieldDropdown,
  FieldImage,
  FieldLabel,
  FieldLabelSerializable,
  FieldNavigationPolicy,
  FieldNumber,
  FieldTextInput,
  FieldVariable,
  Flyout,
  FlyoutButton,
  FlyoutButtonNavigationPolicy,
  FlyoutItem,
  FlyoutMetricsManager,
  FlyoutNavigationPolicy,
  FlyoutNavigator,
  FlyoutSeparator,
  FlyoutSeparatorNavigationPolicy,
  FocusManager,
  FocusableTreeTraverser,
  Generator,
  Gesture,
  Grid,
  HorizontalFlyout,
  INPUT_VALUE,
  Input,
  InsertionMarkerPreviewer,
  KeyboardNavigationController,
  LabelFlyoutInflater,
  LineCursor,
  Marker,
  MarkerManager,
  Menu,
  MenuItem,
  MetricsManager,
  Msg,
  NEXT_STATEMENT,
  Names,
  Navigator,
  OPPOSITE_TYPE,
  OUTPUT_VALUE,
  Options,
  PREVIOUS_STATEMENT,
  PROCEDURE_CATEGORY_NAME,
  Procedures,
  RENAME_VARIABLE_ID,
  RenderedConnection,
  Scrollbar,
  ScrollbarPair,
  SeparatorFlyoutInflater,
  ShortcutItems,
  ShortcutRegistry,
  TOOLBOX_AT_BOTTOM,
  TOOLBOX_AT_LEFT,
  TOOLBOX_AT_RIGHT,
  TOOLBOX_AT_TOP,
  Theme,
  ThemeManager,
  Themes,
  Toast,
  Toolbox,
  ToolboxCategory,
  ToolboxItem,
  ToolboxSeparator,
  Tooltip,
  Touch,
  Trashcan,
  UnattachedFieldError,
  VARIABLE_CATEGORY_NAME,
  VARIABLE_DYNAMIC_CATEGORY_NAME,
  VERSION,
  VariableMap,
  VariableModel,
  Variables,
  VariablesDynamic,
  VerticalFlyout,
  WidgetDiv,
  Workspace,
  WorkspaceAudio,
  WorkspaceDragger,
  WorkspaceNavigationPolicy,
  WorkspaceSvg,
  Xml,
  ZoomControls,
  blockAnimations,
  blockRendering,
  browserEvents,
  bubbles,
  bumpObjects,
  clipboard,
  comments,
  common,
  config,
  constants,
  defineBlocksWithJsonArray,
  dialog,
  dragging,
  fieldRegistry,
  geras,
  getFocusManager,
  getMainWorkspace,
  getSelected,
  hasBubble,
  hideChaff,
  icons,
  inject,
  inputs,
  isCopyable,
  isDeletable,
  isDraggable,
  isIcon,
  isObservable,
  isPaster,
  isRenderedElement,
  isSelectable,
  isSerializable,
  isVariableBackedParameterModel,
  keyboardNavigationController,
  layers,
  navigateBlock,
  navigateStacks,
  procedures,
  registry,
  renderManagement,
  serialization,
  setLocale,
  setParentContainer,
  svgResize,
  thrasos,
  uiPosition,
  utils,
  zelos
} = import_blockly_compressed.default;

// node_modules/@blockly/continuous-toolbox/src/ContinuousCategory.ts
var ContinuousCategory = class extends ToolboxCategory {
  /**
   * Creates a DOM element to display the category's label.
   *
   * @param name The name of this category.
   * @returns The newly created category label DOM element.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  createLabelDom_(name2) {
    const label = document.createElement("div");
    label.setAttribute("id", this.getId() + ".label");
    label.textContent = name2;
    label.classList.add(this.cssConfig_["label"] ?? "");
    return label;
  }
  /**
   * Creates a DOM element to display the category's icon. This category uses
   * color swatches instead of graphical icons.
   *
   * @returns The newly created category icon DOM element.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  createIconDom_() {
    const icon = document.createElement("div");
    icon.classList.add("categoryBubble");
    icon.style.backgroundColor = this.colour_;
    return icon;
  }
  /**
   * Adds a color indicator to the toolbox category. Intentionally a no-op.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  addColourBorder_() {
  }
  /**
   * Sets whether or not this category is selected in the toolbox.
   *
   * @param isSelected True if this category is selected, otherwise false.
   */
  setSelected(isSelected) {
    if (!this.rowDiv_ || !this.htmlDiv_) return;
    if (isSelected) {
      this.rowDiv_.style.backgroundColor = "gray";
      utils.dom.addClass(
        this.rowDiv_,
        this.cssConfig_["selected"] ?? ""
      );
    } else {
      this.rowDiv_.style.backgroundColor = "";
      utils.dom.removeClass(
        this.rowDiv_,
        this.cssConfig_["selected"] ?? ""
      );
    }
    utils.aria.setState(
      this.htmlDiv_,
      utils.aria.State.SELECTED,
      isSelected
    );
  }
};

// node_modules/@blockly/continuous-toolbox/src/ContinuousFlyoutMetrics.ts
var ContinuousFlyoutMetrics = class extends FlyoutMetricsManager {
  /**
   * Returns the metrics for the scroll area of the continuous flyout's
   * workspace. Adds additional padding to the bottom of the flyout if needed in
   * order to make it possible  to scroll to the top of the last category.
   *
   * @param getWorkspaceCoordinates True to get the scroll metrics in
   *     workspace coordinates, false to get them in pixel coordinates.
   * @param cachedViewMetrics The view metrics if they have been previously
   *     computed.
   * @param cachedContentMetrics The content metrics if they have been
   *     previously computed.
   * @returns The metrics for the scroll container.
   */
  getScrollMetrics(getWorkspaceCoordinates, cachedViewMetrics, cachedContentMetrics) {
    const scrollMetrics = super.getScrollMetrics(
      getWorkspaceCoordinates,
      cachedViewMetrics,
      cachedContentMetrics
    );
    const contentMetrics = cachedContentMetrics || this.getContentMetrics(getWorkspaceCoordinates);
    const viewMetrics = cachedViewMetrics || this.getViewMetrics(getWorkspaceCoordinates);
    if (scrollMetrics) {
      scrollMetrics.height += this.flyout_.calculateBottomPadding(contentMetrics, viewMetrics);
    }
    return scrollMetrics;
  }
};

// node_modules/@blockly/continuous-toolbox/src/RecyclableBlockFlyoutInflater.ts
var RecyclableBlockFlyoutInflater = class extends BlockFlyoutInflater {
  constructor() {
    super(...arguments);
    /**
     * Whether or not block recycling is enabled.
     */
    __publicField(this, "recyclingEnabled", false);
    /**
     * Map from block type to block instance.
     */
    __publicField(this, "recycledBlocks", /* @__PURE__ */ new Map());
    /**
     * Custom function to use for checking whether or not blocks can be recycled.
     */
    __publicField(this, "recycleEligibilityChecker");
  }
  /**
   * Creates a new block from the given block definition.
   *
   * @param blockDefinition The definition to create a block from.
   * @param workspace The workspace to create the block on.
   * @returns The newly created block.
   */
  createBlock(blockDefinition, workspace) {
    const blockType = this.getTypeFromDefinition(blockDefinition);
    return this.getRecycledBlock(blockType) ?? super.createBlock(blockDefinition, workspace);
  }
  /**
   * Returns the type of a block from an XML or JSON block definition.
   *
   * @param blockDefinition The block definition to parse.
   * @returns The block type.
   */
  getTypeFromDefinition(blockDefinition) {
    let type;
    if (blockDefinition["blockxml"]) {
      const xml = typeof blockDefinition["blockxml"] === "string" ? utils.xml.textToDom(blockDefinition["blockxml"]) : blockDefinition["blockxml"];
      type = xml.getAttribute("type");
    } else {
      type = blockDefinition["type"];
    }
    if (!type) {
      throw new Error(
        `Block type is not specified in block definition: ${JSON.stringify(
          blockDefinition
        )}`
      );
    }
    return type;
  }
  /**
   * Puts a previously created block into the recycle bin and moves it to the
   * top of the workspace. Used during large workspace swaps to limit the number
   * of new DOM elements we need to create.
   *
   * @param block The block to recycle.
   */
  recycleBlock(block) {
    const xy = block.getRelativeToSurfaceXY();
    block.moveBy(-xy.x, -xy.y);
    this.recycledBlocks.set(block.type, block);
  }
  /**
   * Returns a block from the cache of recycled blocks with the given type, or
   * undefined if one cannot be found.
   *
   * @param blockType The type of the block to try to recycle.
   * @returns The recycled block, or undefined if one could not be recycled.
   */
  getRecycledBlock(blockType) {
    const block = this.recycledBlocks.get(blockType);
    this.recycledBlocks.delete(blockType);
    return block;
  }
  /**
   * Returns whether the given block can be recycled or not.
   *
   * @param block The block to check for recyclability.
   * @returns True if the block can be recycled. False otherwise.
   */
  blockIsRecyclable(block) {
    if (!this.recyclingEnabled) return false;
    if (this.recycleEligibilityChecker) {
      return this.recycleEligibilityChecker(block);
    }
    if (block.mutationToDom || block.domToMutation || block.saveExtraState || block.loadExtraState) {
      return false;
    }
    if (!block.isEnabled()) return false;
    for (const input of block.inputList) {
      for (const field of input.fieldRow) {
        if (field.referencesVariables()) return false;
        if (field instanceof FieldDropdown) {
          if (field.isOptionListDynamic()) return false;
        }
      }
      if (input.connection) {
        const targetBlock = input.connection.targetBlock();
        if (targetBlock && !this.blockIsRecyclable(targetBlock)) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Disposes of the provided block.
   *
   * @param item The block to dispose of.
   */
  disposeItem(item) {
    const element = item.getElement();
    if (element instanceof BlockSvg && this.blockIsRecyclable(element)) {
      this.removeListeners(element.id);
      this.recycleBlock(element);
    } else {
      super.disposeItem(item);
    }
  }
  /**
   * Clears the cache of recycled blocks.
   */
  emptyRecycledBlocks() {
    this.recycledBlocks.forEach((block) => block.dispose(false, false));
    this.recycledBlocks.clear();
  }
};

// node_modules/@blockly/continuous-toolbox/src/ContinuousFlyout.ts
var ContinuousFlyout = class extends VerticalFlyout {
  /**
   * Creates a new ContinuousFlyout.
   *
   * @param workspaceOptions The injection options for the flyout's workspace.
   */
  constructor(workspaceOptions) {
    super(workspaceOptions);
    /**
     * Target scroll position, used to smoothly scroll to a given category
     * location when selected.
     */
    __publicField(this, "scrollTarget");
    /**
     * Map from category name to its position in the flyout.
     */
    __publicField(this, "scrollPositions", /* @__PURE__ */ new Map());
    /**
     * The percentage of the distance to the scrollTarget that should be
     * scrolled at a time. Lower values will produce a smoother, slower scroll.
     */
    __publicField(this, "scrollAnimationFraction", 0.3);
    /**
     * Prevents the flyout from closing automatically when a block is dragged out.
     */
    __publicField(this, "autoClose", false);
    this.getWorkspace().setMetricsManager(
      new ContinuousFlyoutMetrics(this.getWorkspace(), this)
    );
    this.getWorkspace().addChangeListener((e) => {
      if (e.type === Events.VIEWPORT_CHANGE) {
        this.selectCategoryByScrollPosition(-this.getWorkspace().scrollY);
      }
    });
    this.setRecyclingEnabled(true);
  }
  /**
   * Gets parent toolbox.
   * Since we registered the ContinuousToolbox, we know that's its type.
   *
   * @returns Toolbox that owns this flyout.
   */
  getParentToolbox() {
    return this.targetWorkspace.getToolbox();
  }
  /**
   * Records scroll position for each category in the toolbox.
   * The scroll position is determined by the coordinates of each category's
   * label after the entire flyout has been rendered.
   */
  recordScrollPositions() {
    this.scrollPositions.clear();
    this.getContents().filter(this.toolboxItemIsLabel.bind(this)).map((item) => item.getElement()).forEach((label) => {
      this.scrollPositions.set(
        label.getButtonText(),
        Math.max(0, label.getPosition().y - this.GAP_Y / 2)
      );
    });
  }
  /**
   * Validates and typechecks that the given toolbox item represents a label.
   *
   * @param item The toolbox item to check.
   * @returns True if the item represents a label in the flyout, and is a
   *     Blockly.FlyoutButton.
   */
  toolboxItemIsLabel(item) {
    const element = item.getElement();
    return !!(item.getType() === "label" && // Note that `FlyoutButton` represents both buttons and labels.
    element instanceof FlyoutButton && element.isLabel() && this.getParentToolbox().getCategoryByName(element.getButtonText()));
  }
  /**
   * Returns the scroll position for the given category name.
   *
   * @param name Category name.
   * @returns Scroll position for given category in workspace units, or null if
   *     not found.
   */
  getCategoryScrollPosition(name2) {
    const position = this.scrollPositions.get(name2);
    if (position === void 0) {
      console.warn(`Scroll position not recorded for category ${name2}`);
    }
    return position ?? null;
  }
  /**
   * Selects an item in the toolbox based on the scroll position of the flyout.
   *
   * @param position Current scroll position of the workspace.
   */
  selectCategoryByScrollPosition(position) {
    if (this.scrollTarget) return;
    const scaledPosition = Math.round(position / this.getWorkspace().scale);
    for (const [name2, position2] of [
      ...this.scrollPositions.entries()
    ].reverse()) {
      if (scaledPosition >= position2) {
        this.getParentToolbox().selectCategoryByName(name2);
        return;
      }
    }
  }
  /**
   * Scrolls the flyout to given position.
   *
   * @param position The Y coordinate to scroll to.
   */
  scrollTo(position) {
    const metrics = this.getWorkspace().getMetrics();
    this.scrollTarget = Math.min(
      position * this.getWorkspace().scale,
      metrics.scrollHeight - metrics.viewHeight
    );
    this.stepScrollAnimation();
  }
  /**
   * Scrolls the flyout to display the given category at the top.
   *
   * @param category The toolbox category to scroll to in the flyout.
   */
  scrollToCategory(category) {
    const position = this.scrollPositions.get(category.getName());
    if (position === void 0) {
      console.warn(`Scroll position not recorded for category ${name}`);
      return;
    }
    this.scrollTo(position);
  }
  /**
   * Step the scrolling animation by scrolling a fraction of the way to
   * a scroll target, and request the next frame if necessary.
   */
  stepScrollAnimation() {
    var _a, _b;
    if (this.scrollTarget === void 0) return;
    const currentScrollPos = -this.getWorkspace().scrollY;
    const diff = this.scrollTarget - currentScrollPos;
    if (Math.abs(diff) < 1) {
      (_a = this.getWorkspace().scrollbar) == null ? void 0 : _a.setY(this.scrollTarget);
      this.scrollTarget = void 0;
      return;
    }
    (_b = this.getWorkspace().scrollbar) == null ? void 0 : _b.setY(
      currentScrollPos + diff * this.scrollAnimationFraction
    );
    requestAnimationFrame(this.stepScrollAnimation.bind(this));
  }
  /**
   * Handles mouse wheel events.
   *
   * @param e The mouse wheel event to handle.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  wheel_(e) {
    if (this.scrollTarget) return;
    super.wheel_(e);
  }
  /**
   * Calculates the additional padding needed at the bottom of the flyout in
   * order to make it possible to scroll to the top of the last category.
   *
   * @param contentMetrics Content metrics for the flyout.
   * @param viewMetrics View metrics for the flyout.
   * @returns The additional bottom padding needed.
   */
  calculateBottomPadding(contentMetrics, viewMetrics) {
    if (this.scrollPositions.size === 0) return 0;
    const lastPosition = ([...this.scrollPositions.values()].pop() ?? 0) * this.getWorkspace().scale;
    const lastCategoryHeight = contentMetrics.height - lastPosition;
    if (lastCategoryHeight < viewMetrics.height) {
      return viewMetrics.height - lastCategoryHeight;
    }
    return 0;
  }
  /**
   * Returns the X coordinate for the flyout's position.
   */
  getX() {
    if (this.isVisible() && // Make sure that this flyout is associated with a toolbox and not e.g.
    // a simple flyout or the trashcan flyout.
    this.targetWorkspace.toolboxPosition === this.toolboxPosition_ && this.targetWorkspace.getToolbox() && this.toolboxPosition_ !== utils.toolbox.Position.LEFT) {
      return this.targetWorkspace.getMetricsManager().getViewMetrics().width;
    }
    return super.getX();
  }
  /**
   * Displays the given contents in the flyout.
   *
   * @param flyoutDef A string or JSON object specifying the contents of the
   *     flyout.
   */
  show(flyoutDef) {
    super.show(flyoutDef);
    this.recordScrollPositions();
    this.getWorkspace().resizeContents();
    if (!this.getParentToolbox().getSelectedItem()) {
      this.selectCategoryByScrollPosition(0);
    }
    this.getRecyclableInflater().emptyRecycledBlocks();
  }
  /**
   * Sets the function used to determine whether a block is recyclable.
   *
   * @param func The function used to determine if a block is recyclable.
   */
  setBlockIsRecyclable(func) {
    this.getRecyclableInflater().recycleEligibilityChecker = func;
  }
  /**
   * Set whether the flyout can recycle blocks.
   *
   * @param isEnabled True to allow blocks to be recycled, false otherwise.
   */
  setRecyclingEnabled(isEnabled) {
    this.getRecyclableInflater().recyclingEnabled = isEnabled;
  }
  /**
   * Returns the recyclable block flyout inflater.
   *
   * @returns The recyclable inflater.
   */
  getRecyclableInflater() {
    const inflater = this.getInflaterForType("block");
    if (!(inflater instanceof RecyclableBlockFlyoutInflater)) {
      throw new Error("The RecyclableBlockFlyoutInflater is not registered.");
    }
    return inflater;
  }
};

// node_modules/@blockly/continuous-toolbox/src/ContinuousMetrics.ts
var ContinuousMetrics = class extends MetricsManager {
  /**
   * Computes the viewport size to not include the toolbox and the flyout.
   * The default viewport includes the flyout.
   *
   * @param getWorkspaceCoordinates True to get the view metrics in workspace
   *     coordinates, false to get them in pixel coordinates.
   * @returns The width, height, top and left of the viewport in either
   *     workspace coordinates or pixel coordinates.
   */
  getViewMetrics(getWorkspaceCoordinates = false) {
    const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;
    const svgMetrics = this.getSvgMetrics();
    const toolboxMetrics = this.getToolboxMetrics();
    const flyoutMetrics = this.getFlyoutMetrics(false);
    const toolboxPosition = toolboxMetrics.position;
    if (this.workspace_.getToolbox()) {
      if (toolboxPosition == TOOLBOX_AT_TOP || toolboxPosition == TOOLBOX_AT_BOTTOM) {
        svgMetrics.height -= toolboxMetrics.height + flyoutMetrics.height;
      } else if (toolboxPosition == TOOLBOX_AT_LEFT || toolboxPosition == TOOLBOX_AT_RIGHT) {
        svgMetrics.width -= toolboxMetrics.width + flyoutMetrics.width;
      }
    }
    return {
      height: svgMetrics.height / scale,
      width: svgMetrics.width / scale,
      top: -this.workspace_.scrollY / scale,
      left: -this.workspace_.scrollX / scale
    };
  }
  /**
   * Gets the absolute left and absolute top in pixel coordinates.
   * This is where the visible workspace starts in relation to the SVG
   * container, adjusted to not include the area behind the flyout.
   *
   * @returns The absolute metrics for the workspace.
   */
  getAbsoluteMetrics() {
    const toolboxMetrics = this.getToolboxMetrics();
    const flyoutMetrics = this.getFlyoutMetrics(false);
    const toolboxPosition = toolboxMetrics.position;
    let absoluteLeft = 0;
    if (this.workspace_.getToolbox() && toolboxPosition == TOOLBOX_AT_LEFT) {
      absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;
    }
    let absoluteTop = 0;
    if (this.workspace_.getToolbox() && toolboxPosition == TOOLBOX_AT_TOP) {
      absoluteTop = toolboxMetrics.height + flyoutMetrics.height;
    }
    return {
      top: absoluteTop,
      left: absoluteLeft
    };
  }
};

// node_modules/@blockly/continuous-toolbox/src/ContinuousToolbox.ts
var ContinuousToolbox = class extends Toolbox {
  constructor() {
    super(...arguments);
    /**
     * Timeout ID used to prevent refreshing the flyout during extensive block
     * changes.
     */
    __publicField(this, "refreshDebouncer");
  }
  /**
   * Initializes the continuous toolbox.
   */
  init() {
    super.init();
    const flyout = this.getFlyout();
    flyout.show(this.getInitialFlyoutContents());
    this.getWorkspace().addChangeListener((e) => {
      if (e.type === Events.BLOCK_CREATE || e.type === Events.BLOCK_DELETE || e.type === Events.BLOCK_CHANGE) {
        this.refreshSelection();
      }
    });
  }
  /**
   * Returns the continuous toolbox's flyout.
   *
   * @returns The toolbox's flyout.
   */
  getFlyout() {
    return super.getFlyout();
  }
  /**
   * Gets the contents that should be shown in the flyout immediately.
   * This includes all blocks and labels for each category of block.
   *
   * @returns Flyout contents.
   */
  getInitialFlyoutContents() {
    return this.getToolboxItems().flatMap(this.convertToolboxItemToFlyoutItems);
  }
  /**
   * Converts a given toolbox item to an array of flyout items, generally a
   * label followed by the category's blocks.
   *
   * @param toolboxItem The toolbox item/category to convert.
   * @returns An array of flyout items contained in the given toolbox item.
   */
  convertToolboxItemToFlyoutItems(toolboxItem) {
    let contents = [];
    if (toolboxItem instanceof ToolboxCategory) {
      contents.push({ kind: "LABEL", text: toolboxItem.getName() });
      let itemContents = toolboxItem.getContents();
      if (typeof itemContents === "string") {
        itemContents = [{ custom: itemContents, kind: "CATEGORY" }];
      }
      contents = contents.concat(itemContents);
    }
    return contents;
  }
  /**
   * Updates the flyout's contents if it is visible.
   */
  refreshSelection() {
    if (this.getFlyout().isVisible()) {
      if (this.refreshDebouncer) {
        clearTimeout(this.refreshDebouncer);
      }
      this.refreshDebouncer = setTimeout(() => {
        this.getFlyout().show(this.getInitialFlyoutContents());
      }, 100);
    }
  }
  /**
   * Scrolls the flyout to display the newly selected category's contents.
   *
   * @param oldItem The previously selected toolbox category.
   * @param newItem The newly selected toolbox category.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  updateFlyout_(oldItem, newItem) {
    if (newItem) {
      this.getFlyout().scrollToCategory(newItem);
      if (!this.getFlyout().isVisible()) {
        this.getFlyout().show(this.getInitialFlyoutContents());
      }
    } else if (this.getFlyout().autoClose) {
      this.getFlyout().hide();
    }
  }
  /**
   * Returns whether or not the toolbox should deselect the old category.
   *
   * @param oldItem The previously selected toolbox category.
   * @param newItem The newly selected toolbox category.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  shouldDeselectItem_(oldItem, newItem) {
    return !!(oldItem && oldItem !== newItem);
  }
  /**
   * Gets a category by name.
   *
   * @param name Name of category to get.
   * @returns Category, or null if not found.
   * @internal
   */
  getCategoryByName(name2) {
    const category = this.getToolboxItems().find(
      (item) => item instanceof ToolboxCategory && item.isSelectable() && name2 === item.getName()
    );
    if (!category) return null;
    return category;
  }
  /**
   * Selects the category with the given name.
   * Similar to setSelectedItem, but importantly, does not call updateFlyout
   * because this is called while the flyout is being scrolled.
   *
   * @param name Name of category to select.
   * @internal
   */
  selectCategoryByName(name2) {
    const newItem = this.getCategoryByName(name2);
    if (!newItem) return;
    const oldItem = this.selectedItem_;
    if (oldItem && this.shouldDeselectItem_(oldItem, newItem)) {
      this.deselectItem_(oldItem);
    }
    if (this.shouldSelectItem_(oldItem, newItem)) {
      this.selectItem_(oldItem, newItem);
    }
  }
  /**
   * Returns the bounding rectangle of the drag target/deletion area in pixels
   * relative to the viewport.
   *
   * @returns The toolbox's bounding box. Null if drag target area should be
   *     ignored.
   */
  getClientRect() {
    const flyout = this.getFlyout();
    if (flyout && !flyout.autoClose) {
      return flyout.getClientRect();
    }
    return super.getClientRect();
  }
};

// node_modules/@blockly/continuous-toolbox/src/index.ts
function registerContinuousToolbox() {
  registry.register(
    registry.Type.TOOLBOX_ITEM,
    ToolboxCategory.registrationName,
    ContinuousCategory,
    true
  );
  registry.register(
    registry.Type.METRICS_MANAGER,
    "ContinuousMetrics",
    ContinuousMetrics,
    true
  );
  registry.register(
    registry.Type.FLYOUTS_VERTICAL_TOOLBOX,
    "ContinuousFlyout",
    ContinuousFlyout,
    true
  );
  registry.register(
    registry.Type.TOOLBOX,
    "ContinuousToolbox",
    ContinuousToolbox,
    true
  );
  registry.register(
    registry.Type.FLYOUT_INFLATER,
    "block",
    RecyclableBlockFlyoutInflater,
    true
  );
  Css.register(`
  .categoryBubble {
    margin: 0 auto 0.125rem;
    border-radius: 100%;
    border: 1px solid;
    width: 1.25rem;
    height: 1.25rem;
  }
  .blocklyToolboxCategory {
    height: initial;
    padding: 3px 0;
  }
  .blocklyTreeRowContentContainer {
    display: flex;
    flex-direction: column;
  }
  .blocklyTreeLabel {
    margin: auto;
  }
  .blocklyToolboxCategoryLabel {
    text-align: center;
  }
  `);
}
export {
  ContinuousCategory,
  ContinuousFlyout,
  ContinuousMetrics,
  ContinuousToolbox,
  RecyclableBlockFlyoutInflater,
  registerContinuousToolbox
};
/*! Bundled license information:

@blockly/continuous-toolbox/src/ContinuousCategory.ts:
@blockly/continuous-toolbox/src/ContinuousFlyout.ts:
@blockly/continuous-toolbox/src/ContinuousToolbox.ts:
@blockly/continuous-toolbox/src/index.ts:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@blockly/continuous-toolbox/src/ContinuousFlyoutMetrics.ts:
@blockly/continuous-toolbox/src/ContinuousMetrics.ts:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)

@blockly/continuous-toolbox/src/RecyclableBlockFlyoutInflater.ts:
  (**
   * @license
   * Copyright 2024 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@blockly_continuous-toolbox.js.map
