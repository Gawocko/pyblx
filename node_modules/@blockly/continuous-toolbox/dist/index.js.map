{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/continuous-toolbox/webpack/universalModuleDefinition","webpack://@blockly/continuous-toolbox/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/continuous-toolbox/webpack/bootstrap","webpack://@blockly/continuous-toolbox/webpack/runtime/define property getters","webpack://@blockly/continuous-toolbox/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/continuous-toolbox/webpack/runtime/make namespace object","webpack://@blockly/continuous-toolbox/./src/ContinuousCategory.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousFlyoutMetrics.ts","webpack://@blockly/continuous-toolbox/./src/RecyclableBlockFlyoutInflater.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousFlyout.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousMetrics.ts","webpack://@blockly/continuous-toolbox/./src/ContinuousToolbox.ts","webpack://@blockly/continuous-toolbox/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox category with styling for continuous toolbox.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Toolbox category for continuous toolbox. */\nexport class ContinuousCategory extends Blockly.ToolboxCategory {\n  /**\n   * Creates a DOM element to display the category's label.\n   *\n   * @param name The name of this category.\n   * @returns The newly created category label DOM element.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override createLabelDom_(name: string): Element {\n    const label = document.createElement('div');\n    label.setAttribute('id', this.getId() + '.label');\n    label.textContent = name;\n    label.classList.add(this.cssConfig_['label'] ?? '');\n    return label;\n  }\n\n  /**\n   * Creates a DOM element to display the category's icon. This category uses\n   * color swatches instead of graphical icons.\n   *\n   * @returns The newly created category icon DOM element.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override createIconDom_(): Element {\n    const icon = document.createElement('div');\n    icon.classList.add('categoryBubble');\n    icon.style.backgroundColor = this.colour_;\n    return icon;\n  }\n\n  /**\n   * Adds a color indicator to the toolbox category. Intentionally a no-op.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override addColourBorder_() {\n    // No-op\n  }\n\n  /**\n   * Sets whether or not this category is selected in the toolbox.\n   *\n   * @param isSelected True if this category is selected, otherwise false.\n   */\n  override setSelected(isSelected: boolean) {\n    if (!this.rowDiv_ || !this.htmlDiv_) return;\n    if (isSelected) {\n      this.rowDiv_.style.backgroundColor = 'gray';\n      Blockly.utils.dom.addClass(\n        this.rowDiv_,\n        this.cssConfig_['selected'] ?? '',\n      );\n    } else {\n      this.rowDiv_.style.backgroundColor = '';\n      Blockly.utils.dom.removeClass(\n        this.rowDiv_,\n        this.cssConfig_['selected'] ?? '',\n      );\n    }\n    Blockly.utils.aria.setState(\n      this.htmlDiv_,\n      Blockly.utils.aria.State.SELECTED,\n      isSelected,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport type {ContinuousFlyout} from './ContinuousFlyout';\n\n/** Adds additional padding to the bottom of the flyout if needed. */\nexport class ContinuousFlyoutMetrics extends Blockly.FlyoutMetricsManager {\n  /**\n   * Returns the metrics for the scroll area of the continuous flyout's\n   * workspace. Adds additional padding to the bottom of the flyout if needed in\n   * order to make it possible  to scroll to the top of the last category.\n   *\n   * @param getWorkspaceCoordinates True to get the scroll metrics in\n   *     workspace coordinates, false to get them in pixel coordinates.\n   * @param cachedViewMetrics The view metrics if they have been previously\n   *     computed.\n   * @param cachedContentMetrics The content metrics if they have been\n   *     previously computed.\n   * @returns The metrics for the scroll container.\n   */\n  override getScrollMetrics(\n    getWorkspaceCoordinates?: boolean,\n    cachedViewMetrics?: Blockly.MetricsManager.ContainerRegion,\n    cachedContentMetrics?: Blockly.MetricsManager.ContainerRegion,\n  ) {\n    const scrollMetrics = super.getScrollMetrics(\n      getWorkspaceCoordinates,\n      cachedViewMetrics,\n      cachedContentMetrics,\n    );\n    const contentMetrics =\n      cachedContentMetrics || this.getContentMetrics(getWorkspaceCoordinates);\n    const viewMetrics =\n      cachedViewMetrics || this.getViewMetrics(getWorkspaceCoordinates);\n\n    if (scrollMetrics) {\n      scrollMetrics.height += (\n        this.flyout_ as ContinuousFlyout\n      ).calculateBottomPadding(contentMetrics, viewMetrics);\n    }\n    return scrollMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * A block inflater that caches and reuses blocks to improve performance.\n */\nexport class RecyclableBlockFlyoutInflater extends Blockly.BlockFlyoutInflater {\n  /**\n   * Whether or not block recycling is enabled.\n   */\n  recyclingEnabled = false;\n\n  /**\n   * Map from block type to block instance.\n   */\n  private recycledBlocks = new Map<string, Blockly.BlockSvg>();\n\n  /**\n   * Custom function to use for checking whether or not blocks can be recycled.\n   */\n  recycleEligibilityChecker?: (block: Blockly.Block) => boolean;\n\n  /**\n   * Creates a new block from the given block definition.\n   *\n   * @param blockDefinition The definition to create a block from.\n   * @param workspace The workspace to create the block on.\n   * @returns The newly created block.\n   */\n  override createBlock(\n    blockDefinition: Blockly.utils.toolbox.BlockInfo,\n    workspace: Blockly.WorkspaceSvg,\n  ): Blockly.BlockSvg {\n    const blockType = this.getTypeFromDefinition(blockDefinition);\n    return (\n      this.getRecycledBlock(blockType) ??\n      super.createBlock(blockDefinition, workspace)\n    );\n  }\n\n  /**\n   * Returns the type of a block from an XML or JSON block definition.\n   *\n   * @param blockDefinition The block definition to parse.\n   * @returns The block type.\n   */\n  private getTypeFromDefinition(\n    blockDefinition: Blockly.utils.toolbox.BlockInfo,\n  ): string {\n    let type: string | null | undefined;\n    if (blockDefinition['blockxml']) {\n      const xml =\n        typeof blockDefinition['blockxml'] === 'string'\n          ? Blockly.utils.xml.textToDom(blockDefinition['blockxml'])\n          : (blockDefinition['blockxml'] as Element);\n      type = xml.getAttribute('type');\n    } else {\n      type = blockDefinition['type'];\n    }\n\n    if (!type) {\n      throw new Error(\n        `Block type is not specified in block definition: ${JSON.stringify(\n          blockDefinition,\n        )}`,\n      );\n    }\n    return type;\n  }\n\n  /**\n   * Puts a previously created block into the recycle bin and moves it to the\n   * top of the workspace. Used during large workspace swaps to limit the number\n   * of new DOM elements we need to create.\n   *\n   * @param block The block to recycle.\n   */\n  private recycleBlock(block: Blockly.BlockSvg) {\n    const xy = block.getRelativeToSurfaceXY();\n    block.moveBy(-xy.x, -xy.y);\n    this.recycledBlocks.set(block.type, block);\n  }\n\n  /**\n   * Returns a block from the cache of recycled blocks with the given type, or\n   * undefined if one cannot be found.\n   *\n   * @param blockType The type of the block to try to recycle.\n   * @returns The recycled block, or undefined if one could not be recycled.\n   */\n  private getRecycledBlock(blockType: string): Blockly.BlockSvg | undefined {\n    const block = this.recycledBlocks.get(blockType);\n    this.recycledBlocks.delete(blockType);\n    return block;\n  }\n\n  /**\n   * Returns whether the given block can be recycled or not.\n   *\n   * @param block The block to check for recyclability.\n   * @returns True if the block can be recycled. False otherwise.\n   */\n  protected blockIsRecyclable(block: Blockly.Block): boolean {\n    if (!this.recyclingEnabled) return false;\n\n    if (this.recycleEligibilityChecker) {\n      return this.recycleEligibilityChecker(block);\n    }\n\n    // If the block needs to parse mutations, never recycle.\n    if (\n      block.mutationToDom ||\n      block.domToMutation ||\n      block.saveExtraState ||\n      block.loadExtraState\n    ) {\n      return false;\n    }\n\n    if (!block.isEnabled()) return false;\n\n    for (const input of block.inputList) {\n      for (const field of input.fieldRow) {\n        // No variables.\n        if (field.referencesVariables()) return false;\n\n        if (field instanceof Blockly.FieldDropdown) {\n          if (field.isOptionListDynamic()) return false;\n        }\n      }\n      // Check children.\n      if (input.connection) {\n        const targetBlock = input.connection.targetBlock();\n        if (targetBlock && !this.blockIsRecyclable(targetBlock)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Disposes of the provided block.\n   *\n   * @param item The block to dispose of.\n   */\n  override disposeItem(item: Blockly.FlyoutItem) {\n    const element = item.getElement();\n    if (\n      element instanceof Blockly.BlockSvg &&\n      this.blockIsRecyclable(element)\n    ) {\n      this.removeListeners(element.id);\n      this.recycleBlock(element);\n    } else {\n      super.disposeItem(item);\n    }\n  }\n\n  /**\n   * Clears the cache of recycled blocks.\n   */\n  emptyRecycledBlocks() {\n    this.recycledBlocks.forEach((block) => block.dispose(false, false));\n    this.recycledBlocks.clear();\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Flyout that supports always-open continuous scrolling.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {ContinuousFlyoutMetrics} from './ContinuousFlyoutMetrics';\nimport {RecyclableBlockFlyoutInflater} from './RecyclableBlockFlyoutInflater';\n\nexport interface LabelFlyoutItem extends Blockly.FlyoutItem {\n  // Blockly.FlyoutButton represents both buttons and labels; a label is just\n  // a borderless, non-clickable button.\n  getElement(): Blockly.FlyoutButton;\n}\n\n/**\n * Class for continuous flyout.\n */\nexport class ContinuousFlyout extends Blockly.VerticalFlyout {\n  /**\n   * Target scroll position, used to smoothly scroll to a given category\n   * location when selected.\n   */\n  private scrollTarget?: number;\n\n  /**\n   * Map from category name to its position in the flyout.\n   */\n  private scrollPositions = new Map<string, number>();\n\n  /**\n   * The percentage of the distance to the scrollTarget that should be\n   * scrolled at a time. Lower values will produce a smoother, slower scroll.\n   */\n  protected scrollAnimationFraction = 0.3;\n\n  /**\n   * Prevents the flyout from closing automatically when a block is dragged out.\n   */\n  override autoClose = false;\n\n  /**\n   * Creates a new ContinuousFlyout.\n   *\n   * @param workspaceOptions The injection options for the flyout's workspace.\n   */\n  constructor(workspaceOptions: Blockly.Options) {\n    super(workspaceOptions);\n\n    this.getWorkspace().setMetricsManager(\n      new ContinuousFlyoutMetrics(this.getWorkspace(), this),\n    );\n\n    this.getWorkspace().addChangeListener((e: Blockly.Events.Abstract) => {\n      if (e.type === Blockly.Events.VIEWPORT_CHANGE) {\n        this.selectCategoryByScrollPosition(-this.getWorkspace().scrollY);\n      }\n    });\n\n    this.setRecyclingEnabled(true);\n  }\n\n  /**\n   * Gets parent toolbox.\n   * Since we registered the ContinuousToolbox, we know that's its type.\n   *\n   * @returns Toolbox that owns this flyout.\n   */\n  private getParentToolbox(): ContinuousToolbox {\n    return this.targetWorkspace.getToolbox() as ContinuousToolbox;\n  }\n\n  /**\n   * Records scroll position for each category in the toolbox.\n   * The scroll position is determined by the coordinates of each category's\n   * label after the entire flyout has been rendered.\n   */\n  private recordScrollPositions() {\n    this.scrollPositions.clear();\n    this.getContents()\n      .filter(this.toolboxItemIsLabel.bind(this))\n      .map((item) => item.getElement())\n      .forEach((label) => {\n        this.scrollPositions.set(\n          label.getButtonText(),\n          Math.max(0, label.getPosition().y - this.GAP_Y / 2),\n        );\n      });\n  }\n\n  /**\n   * Validates and typechecks that the given toolbox item represents a label.\n   *\n   * @param item The toolbox item to check.\n   * @returns True if the item represents a label in the flyout, and is a\n   *     Blockly.FlyoutButton.\n   */\n  protected toolboxItemIsLabel(\n    item: Blockly.FlyoutItem,\n  ): item is LabelFlyoutItem {\n    const element = item.getElement();\n    return !!(\n      item.getType() === 'label' &&\n      // Note that `FlyoutButton` represents both buttons and labels.\n      element instanceof Blockly.FlyoutButton &&\n      element.isLabel() &&\n      this.getParentToolbox().getCategoryByName(element.getButtonText())\n    );\n  }\n\n  /**\n   * Returns the scroll position for the given category name.\n   *\n   * @param name Category name.\n   * @returns Scroll position for given category in workspace units, or null if\n   *     not found.\n   */\n  getCategoryScrollPosition(name: string): number | null {\n    const position = this.scrollPositions.get(name);\n    if (position === undefined) {\n      console.warn(`Scroll position not recorded for category ${name}`);\n    }\n    return position ?? null;\n  }\n\n  /**\n   * Selects an item in the toolbox based on the scroll position of the flyout.\n   *\n   * @param position Current scroll position of the workspace.\n   */\n  private selectCategoryByScrollPosition(position: number) {\n    // If we are currently auto-scrolling, due to selecting a category by\n    // clicking on it, do not update the category selection.\n    if (this.scrollTarget) return;\n\n    const scaledPosition = Math.round(position / this.getWorkspace().scale);\n    // Traverse the array of scroll positions in reverse, so we can select the\n    // furthest category that the scroll position is beyond.\n    for (const [name, position] of [\n      ...this.scrollPositions.entries(),\n    ].reverse()) {\n      if (scaledPosition >= position) {\n        this.getParentToolbox().selectCategoryByName(name);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Scrolls the flyout to given position.\n   *\n   * @param position The Y coordinate to scroll to.\n   */\n  scrollTo(position: number) {\n    // Set the scroll target to either the scaled position or the lowest\n    // possible scroll point, whichever is smaller.\n    const metrics = this.getWorkspace().getMetrics();\n    this.scrollTarget = Math.min(\n      position * this.getWorkspace().scale,\n      metrics.scrollHeight - metrics.viewHeight,\n    );\n\n    this.stepScrollAnimation();\n  }\n\n  /**\n   * Scrolls the flyout to display the given category at the top.\n   *\n   * @param category The toolbox category to scroll to in the flyout.\n   */\n  scrollToCategory(category: Blockly.ISelectableToolboxItem) {\n    const position = this.scrollPositions.get(category.getName());\n    if (position === undefined) {\n      console.warn(`Scroll position not recorded for category ${name}`);\n      return;\n    }\n    this.scrollTo(position);\n  }\n\n  /**\n   * Step the scrolling animation by scrolling a fraction of the way to\n   * a scroll target, and request the next frame if necessary.\n   */\n  private stepScrollAnimation() {\n    if (this.scrollTarget === undefined) return;\n    const currentScrollPos = -this.getWorkspace().scrollY;\n    const diff = this.scrollTarget - currentScrollPos;\n    if (Math.abs(diff) < 1) {\n      this.getWorkspace().scrollbar?.setY(this.scrollTarget);\n      this.scrollTarget = undefined;\n      return;\n    }\n    this.getWorkspace().scrollbar?.setY(\n      currentScrollPos + diff * this.scrollAnimationFraction,\n    );\n\n    requestAnimationFrame(this.stepScrollAnimation.bind(this));\n  }\n\n  /**\n   * Handles mouse wheel events.\n   *\n   * @param e The mouse wheel event to handle.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  protected override wheel_(e: WheelEvent) {\n    // Don't scroll in response to mouse wheel events if we're currently\n    // animating scrolling to a category.\n    if (this.scrollTarget) return;\n\n    super.wheel_(e);\n  }\n\n  /**\n   * Calculates the additional padding needed at the bottom of the flyout in\n   * order to make it possible to scroll to the top of the last category.\n   *\n   * @param contentMetrics Content metrics for the flyout.\n   * @param viewMetrics View metrics for the flyout.\n   * @returns The additional bottom padding needed.\n   */\n  calculateBottomPadding(\n    contentMetrics: Blockly.MetricsManager.ContainerRegion,\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n  ): number {\n    if (this.scrollPositions.size === 0) return 0;\n\n    const lastPosition =\n      ([...this.scrollPositions.values()].pop() ?? 0) *\n      this.getWorkspace().scale;\n    const lastCategoryHeight = contentMetrics.height - lastPosition;\n    if (lastCategoryHeight < viewMetrics.height) {\n      return viewMetrics.height - lastCategoryHeight;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Returns the X coordinate for the flyout's position.\n   */\n  override getX(): number {\n    if (\n      this.isVisible() &&\n      // Make sure that this flyout is associated with a toolbox and not e.g.\n      // a simple flyout or the trashcan flyout.\n      this.targetWorkspace.toolboxPosition === this.toolboxPosition_ &&\n      this.targetWorkspace.getToolbox() &&\n      this.toolboxPosition_ !== Blockly.utils.toolbox.Position.LEFT\n    ) {\n      // This makes it so blocks cannot go under the flyout in RTL mode.\n      return this.targetWorkspace.getMetricsManager().getViewMetrics().width;\n    }\n\n    return super.getX();\n  }\n\n  /**\n   * Displays the given contents in the flyout.\n   *\n   * @param flyoutDef A string or JSON object specifying the contents of the\n   *     flyout.\n   */\n  override show(flyoutDef: Blockly.utils.toolbox.FlyoutDefinition | string) {\n    super.show(flyoutDef);\n    this.recordScrollPositions();\n    this.getWorkspace().resizeContents();\n    if (!this.getParentToolbox().getSelectedItem()) {\n      this.selectCategoryByScrollPosition(0);\n    }\n    this.getRecyclableInflater().emptyRecycledBlocks();\n  }\n\n  /**\n   * Sets the function used to determine whether a block is recyclable.\n   *\n   * @param func The function used to determine if a block is recyclable.\n   */\n  setBlockIsRecyclable(func: (block: Blockly.Block) => boolean) {\n    this.getRecyclableInflater().recycleEligibilityChecker = func;\n  }\n\n  /**\n   * Set whether the flyout can recycle blocks.\n   *\n   * @param isEnabled True to allow blocks to be recycled, false otherwise.\n   */\n  setRecyclingEnabled(isEnabled: boolean) {\n    this.getRecyclableInflater().recyclingEnabled = isEnabled;\n  }\n\n  /**\n   * Returns the recyclable block flyout inflater.\n   *\n   * @returns The recyclable inflater.\n   */\n  protected getRecyclableInflater(): RecyclableBlockFlyoutInflater {\n    const inflater = this.getInflaterForType('block');\n    if (!(inflater instanceof RecyclableBlockFlyoutInflater)) {\n      throw new Error('The RecyclableBlockFlyoutInflater is not registered.');\n    }\n\n    return inflater;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides metrics to exclude the flyout from the viewport.\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** Computes metrics for a toolbox with an always open flyout. */\nexport class ContinuousMetrics extends Blockly.MetricsManager {\n  /**\n   * Computes the viewport size to not include the toolbox and the flyout.\n   * The default viewport includes the flyout.\n   *\n   * @param getWorkspaceCoordinates True to get the view metrics in workspace\n   *     coordinates, false to get them in pixel coordinates.\n   * @returns The width, height, top and left of the viewport in either\n   *     workspace coordinates or pixel coordinates.\n   */\n  override getViewMetrics(\n    getWorkspaceCoordinates = false,\n  ): Blockly.MetricsManager.ContainerRegion {\n    const scale = getWorkspaceCoordinates ? this.workspace_.scale : 1;\n    const svgMetrics = this.getSvgMetrics();\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n\n    if (this.workspace_.getToolbox()) {\n      // Note: Not actually supported at this time due to ContinuousToolbox\n      // only supporting a vertical flyout. But included for completeness.\n      if (\n        toolboxPosition == Blockly.TOOLBOX_AT_TOP ||\n        toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM\n      ) {\n        svgMetrics.height -= toolboxMetrics.height + flyoutMetrics.height;\n      } else if (\n        toolboxPosition == Blockly.TOOLBOX_AT_LEFT ||\n        toolboxPosition == Blockly.TOOLBOX_AT_RIGHT\n      ) {\n        svgMetrics.width -= toolboxMetrics.width + flyoutMetrics.width;\n      }\n    }\n    return {\n      height: svgMetrics.height / scale,\n      width: svgMetrics.width / scale,\n      top: -this.workspace_.scrollY / scale,\n      left: -this.workspace_.scrollX / scale,\n    };\n  }\n\n  /**\n   * Gets the absolute left and absolute top in pixel coordinates.\n   * This is where the visible workspace starts in relation to the SVG\n   * container, adjusted to not include the area behind the flyout.\n   *\n   * @returns The absolute metrics for the workspace.\n   */\n  override getAbsoluteMetrics(): Blockly.MetricsManager.AbsoluteMetrics {\n    const toolboxMetrics = this.getToolboxMetrics();\n    const flyoutMetrics = this.getFlyoutMetrics(false);\n    const toolboxPosition = toolboxMetrics.position;\n    let absoluteLeft = 0;\n\n    if (\n      this.workspace_.getToolbox() &&\n      toolboxPosition == Blockly.TOOLBOX_AT_LEFT\n    ) {\n      absoluteLeft = toolboxMetrics.width + flyoutMetrics.width;\n    }\n    let absoluteTop = 0;\n    if (\n      this.workspace_.getToolbox() &&\n      toolboxPosition == Blockly.TOOLBOX_AT_TOP\n    ) {\n      absoluteTop = toolboxMetrics.height + flyoutMetrics.height;\n    }\n    return {\n      top: absoluteTop,\n      left: absoluteLeft,\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Toolbox that uses a continuous scrolling flyout.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ContinuousFlyout} from './ContinuousFlyout';\n\n/**\n * Class for continuous toolbox.\n */\nexport class ContinuousToolbox extends Blockly.Toolbox {\n  /**\n   * Timeout ID used to prevent refreshing the flyout during extensive block\n   * changes.\n   */\n  private refreshDebouncer?: ReturnType<typeof setTimeout>;\n\n  /**\n   * Initializes the continuous toolbox.\n   */\n  override init() {\n    super.init();\n\n    // Populate the flyout with all blocks and show it immediately.\n    const flyout = this.getFlyout();\n    flyout.show(this.getInitialFlyoutContents());\n\n    this.getWorkspace().addChangeListener((e: Blockly.Events.Abstract) => {\n      if (\n        e.type === Blockly.Events.BLOCK_CREATE ||\n        e.type === Blockly.Events.BLOCK_DELETE ||\n        e.type === Blockly.Events.BLOCK_CHANGE\n      ) {\n        this.refreshSelection();\n      }\n    });\n  }\n\n  /**\n   * Returns the continuous toolbox's flyout.\n   *\n   * @returns The toolbox's flyout.\n   */\n  override getFlyout(): ContinuousFlyout {\n    return super.getFlyout() as ContinuousFlyout;\n  }\n\n  /**\n   * Gets the contents that should be shown in the flyout immediately.\n   * This includes all blocks and labels for each category of block.\n   *\n   * @returns Flyout contents.\n   */\n  private getInitialFlyoutContents(): Blockly.utils.toolbox.FlyoutItemInfoArray {\n    return this.getToolboxItems().flatMap(this.convertToolboxItemToFlyoutItems);\n  }\n\n  /**\n   * Converts a given toolbox item to an array of flyout items, generally a\n   * label followed by the category's blocks.\n   *\n   * @param toolboxItem The toolbox item/category to convert.\n   * @returns An array of flyout items contained in the given toolbox item.\n   */\n  protected convertToolboxItemToFlyoutItems(\n    toolboxItem: Blockly.IToolboxItem,\n  ): Blockly.utils.toolbox.FlyoutItemInfoArray {\n    let contents: Blockly.utils.toolbox.FlyoutItemInfoArray = [];\n    if (toolboxItem instanceof Blockly.ToolboxCategory) {\n      // Create a label node to go at the top of the category\n      contents.push({kind: 'LABEL', text: toolboxItem.getName()});\n      let itemContents = toolboxItem.getContents();\n\n      // Handle custom categories (e.g. variables and functions)\n      if (typeof itemContents === 'string') {\n        itemContents = [{custom: itemContents, kind: 'CATEGORY'}];\n      }\n      contents = contents.concat(itemContents);\n    }\n    return contents;\n  }\n\n  /**\n   * Updates the flyout's contents if it is visible.\n   */\n  override refreshSelection() {\n    if (this.getFlyout().isVisible()) {\n      if (this.refreshDebouncer) {\n        clearTimeout(this.refreshDebouncer);\n      }\n      this.refreshDebouncer = setTimeout(() => {\n        this.getFlyout().show(this.getInitialFlyoutContents());\n      }, 100);\n    }\n  }\n\n  /**\n   * Scrolls the flyout to display the newly selected category's contents.\n   *\n   * @param oldItem The previously selected toolbox category.\n   * @param newItem The newly selected toolbox category.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override updateFlyout_(\n    oldItem: Blockly.ISelectableToolboxItem | null,\n    newItem: Blockly.ISelectableToolboxItem | null,\n  ) {\n    if (newItem) {\n      this.getFlyout().scrollToCategory(newItem);\n      if (!this.getFlyout().isVisible()) {\n        this.getFlyout().show(this.getInitialFlyoutContents());\n      }\n    } else if (this.getFlyout().autoClose) {\n      this.getFlyout().hide();\n    }\n  }\n\n  /**\n   * Returns whether or not the toolbox should deselect the old category.\n   *\n   * @param oldItem The previously selected toolbox category.\n   * @param newItem The newly selected toolbox category.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  override shouldDeselectItem_(\n    oldItem: Blockly.ISelectableToolboxItem | null,\n    newItem: Blockly.ISelectableToolboxItem | null,\n  ): boolean {\n    // Should not deselect if the same category is clicked again.\n    return !!(oldItem && oldItem !== newItem);\n  }\n\n  /**\n   * Gets a category by name.\n   *\n   * @param name Name of category to get.\n   * @returns Category, or null if not found.\n   * @internal\n   */\n  getCategoryByName(name: string): Blockly.ISelectableToolboxItem | null {\n    const category = this.getToolboxItems().find(\n      (item) =>\n        item instanceof Blockly.ToolboxCategory &&\n        item.isSelectable() &&\n        name === item.getName(),\n    );\n    if (!category) return null;\n    return category as Blockly.ISelectableToolboxItem;\n  }\n\n  /**\n   * Selects the category with the given name.\n   * Similar to setSelectedItem, but importantly, does not call updateFlyout\n   * because this is called while the flyout is being scrolled.\n   *\n   * @param name Name of category to select.\n   * @internal\n   */\n  selectCategoryByName(name: string) {\n    const newItem = this.getCategoryByName(name);\n    if (!newItem) return;\n\n    const oldItem = this.selectedItem_;\n\n    if (oldItem && this.shouldDeselectItem_(oldItem, newItem)) {\n      this.deselectItem_(oldItem);\n    }\n\n    if (this.shouldSelectItem_(oldItem, newItem)) {\n      this.selectItem_(oldItem, newItem);\n    }\n  }\n\n  /**\n   * Returns the bounding rectangle of the drag target/deletion area in pixels\n   * relative to the viewport.\n   *\n   * @returns The toolbox's bounding box. Null if drag target area should be\n   *     ignored.\n   */\n  override getClientRect(): Blockly.utils.Rect | null {\n    // If the flyout never closes, it should be the deletable area.\n    const flyout = this.getFlyout();\n    if (flyout && !flyout.autoClose) {\n      return flyout.getClientRect();\n    }\n    return super.getClientRect();\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Continuous-scroll toolbox and flyout that is always open.\n */\n\nimport * as Blockly from 'blockly/core';\n\nimport {ContinuousCategory} from './ContinuousCategory';\nimport {ContinuousFlyout, LabelFlyoutItem} from './ContinuousFlyout';\nimport {ContinuousMetrics} from './ContinuousMetrics';\nimport {ContinuousToolbox} from './ContinuousToolbox';\nimport {RecyclableBlockFlyoutInflater} from './RecyclableBlockFlyoutInflater';\n\nexport {\n  ContinuousCategory,\n  ContinuousFlyout,\n  ContinuousMetrics,\n  ContinuousToolbox,\n  LabelFlyoutItem,\n  RecyclableBlockFlyoutInflater,\n};\n\n/**\n * Registers the components of the continuous toolbox, replacing Blockly's\n * built-in defaults.\n */\nexport function registerContinuousToolbox() {\n  Blockly.registry.register(\n    Blockly.registry.Type.TOOLBOX_ITEM,\n    Blockly.ToolboxCategory.registrationName,\n    ContinuousCategory,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.METRICS_MANAGER,\n    'ContinuousMetrics',\n    ContinuousMetrics,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.FLYOUTS_VERTICAL_TOOLBOX,\n    'ContinuousFlyout',\n    ContinuousFlyout,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.TOOLBOX,\n    'ContinuousToolbox',\n    ContinuousToolbox,\n    true,\n  );\n\n  Blockly.registry.register(\n    Blockly.registry.Type.FLYOUT_INFLATER,\n    'block',\n    RecyclableBlockFlyoutInflater,\n    true,\n  );\n\n  Blockly.Css.register(`\n  .categoryBubble {\n    margin: 0 auto 0.125rem;\n    border-radius: 100%;\n    border: 1px solid;\n    width: 1.25rem;\n    height: 1.25rem;\n  }\n  .blocklyToolboxCategory {\n    height: initial;\n    padding: 3px 0;\n  }\n  .blocklyTreeRowContentContainer {\n    display: flex;\n    flex-direction: column;\n  }\n  .blocklyTreeLabel {\n    margin: auto;\n  }\n  .blocklyToolboxCategoryLabel {\n    text-align: center;\n  }\n  `);\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ContinuousCategory","createLabelDom_","name","label","document","createElement","setAttribute","getId","textContent","classList","add","cssConfig_","createIconDom_","icon","style","backgroundColor","colour_","addColourBorder_","setSelected","isSelected","rowDiv_","htmlDiv_","dom","addClass","removeClass","aria","setState","State","SELECTED","ContinuousFlyoutMetrics","getScrollMetrics","getWorkspaceCoordinates","cachedViewMetrics","cachedContentMetrics","scrollMetrics","super","contentMetrics","getContentMetrics","viewMetrics","getViewMetrics","height","flyout_","calculateBottomPadding","RecyclableBlockFlyoutInflater","recyclingEnabled","recycledBlocks","Map","createBlock","blockDefinition","workspace","blockType","getTypeFromDefinition","getRecycledBlock","type","xml","textToDom","getAttribute","Error","JSON","stringify","recycleBlock","block","xy","getRelativeToSurfaceXY","moveBy","x","y","set","delete","blockIsRecyclable","recycleEligibilityChecker","mutationToDom","domToMutation","saveExtraState","loadExtraState","isEnabled","input","inputList","field","fieldRow","referencesVariables","isOptionListDynamic","connection","targetBlock","disposeItem","item","element","getElement","removeListeners","id","emptyRecycledBlocks","forEach","dispose","clear","ContinuousFlyout","constructor","workspaceOptions","scrollPositions","scrollAnimationFraction","autoClose","getWorkspace","setMetricsManager","addChangeListener","e","VIEWPORT_CHANGE","selectCategoryByScrollPosition","scrollY","setRecyclingEnabled","getParentToolbox","targetWorkspace","getToolbox","recordScrollPositions","getContents","filter","toolboxItemIsLabel","bind","map","getButtonText","Math","max","getPosition","GAP_Y","getType","isLabel","getCategoryByName","getCategoryScrollPosition","position","console","warn","scrollTarget","scaledPosition","round","scale","entries","reverse","selectCategoryByName","scrollTo","metrics","getMetrics","min","scrollHeight","viewHeight","stepScrollAnimation","scrollToCategory","category","getName","currentScrollPos","diff","abs","scrollbar","setY","requestAnimationFrame","wheel_","size","lastPosition","values","pop","lastCategoryHeight","getX","isVisible","toolboxPosition","toolboxPosition_","toolbox","Position","LEFT","getMetricsManager","width","show","flyoutDef","resizeContents","getSelectedItem","getRecyclableInflater","setBlockIsRecyclable","func","inflater","getInflaterForType","ContinuousMetrics","workspace_","svgMetrics","getSvgMetrics","toolboxMetrics","getToolboxMetrics","flyoutMetrics","getFlyoutMetrics","top","left","scrollX","getAbsoluteMetrics","absoluteLeft","absoluteTop","ContinuousToolbox","init","getFlyout","getInitialFlyoutContents","BLOCK_CREATE","BLOCK_DELETE","BLOCK_CHANGE","refreshSelection","getToolboxItems","flatMap","convertToolboxItemToFlyoutItems","toolboxItem","contents","push","kind","text","itemContents","custom","concat","refreshDebouncer","clearTimeout","setTimeout","updateFlyout_","oldItem","newItem","hide","shouldDeselectItem_","find","isSelectable","selectedItem_","deselectItem_","shouldSelectItem_","selectItem_","getClientRect","flyout","registerContinuousToolbox","register","Type","TOOLBOX_ITEM","registrationName","METRICS_MANAGER","FLYOUTS_VERTICAL_TOOLBOX","TOOLBOX","FLYOUT_INFLATER"],"sourceRoot":""}